 private static class Position {
        private int first, last;

        public Position(int first, int last) {
            this.first = first;
            this.last = last;
        }

        public int getFirst() {
            return first;
        }

        public int getLast() {
            return last;
        }

        public void expand(Position other) {
            this.first = Math.min(this.first, other.first);
            this.last = Math.max(this.last, other.last);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;

            Position that = (Position) o;
            if (first != that.first)
                return false;
            return last == that.last;
        }

        @Override
        public int hashCode() {
            int result = first;
            result = 31 * result + last;
            return result;
        }

        @Override
        public String toString() {
            return "{" + "first=" + first + ", last=" + last + '}';
        }
    }

    --------------------------------------------------------------------------------------------------------------

    private static class Itemset {

            private final int[] items;
            private double support;

            private Itemset(int[] items) {
                this.items = items;
            }

            public int get(int i) {
                return items[i];
            }

            public int size() {
                return items.length;
            }

            public boolean prefixMatch(Itemset other, int prefixSize) {
                // assume sorted and both have size < prefixSize
                for (int i = 0; i < prefixSize; i++) {
                    if (items[i] != other.items[i]) {
                        return false;
                    }
                }
                return true;
            }

            public boolean contains(Itemset other) {
                int i = 0, j = 0;
                while (i < other.items.length && j < this.items.length) {
                    if (this.items[j] < other.items[i]) {
                        j++;
                    } else if (this.items[j] == other.items[i]) {
                        j++;
                        i++;
                    } else if (this.items[j] > other.items[i]) {
                        return false;
                    }
                }
                return i >= other.items.length;
            }

            public Itemset merge(Itemset b, int prefixSize) {
                int[] union = new int[this.items.length + 1];
                System.arraycopy(this.items, 0, union, 0, prefixSize);
                if (this.items[prefixSize] < b.items[prefixSize]) {
                    union[prefixSize] = this.items[prefixSize];
                    union[prefixSize + 1] = b.items[prefixSize];
                } else {
                    union[prefixSize] = b.items[prefixSize];
                    union[prefixSize + 1] = this.items[prefixSize];
                }
                return new Itemset(union);
            }

            @Override
            public boolean equals(Object o) {
                if (this == o)
                    return true;
                if (o == null || getClass() != o.getClass())
                    return false;

                Itemset other = (Itemset) o;
                return Arrays.equals(items, other.items);
            }

            @Override
            public int hashCode() {
                return Arrays.hashCode(items);
            }

            @Override
            public String toString() {
                return "{" + Arrays.stream(items).mapToObj(Integer::toString).collect(Collectors.joining(","))
                        + "}";
            }
        }

        ----------------------------------------------------------------------------------------------------------------------

            private static class ItemPosition {
                private final Map<Integer, Position> itemPosition;

                public ItemPosition() {
                    this.itemPosition = new HashMap<>();
                }

                public void putAndExpand(int item, Position position) {
                    Position pos = itemPosition.get(item);
                    if (pos == null) {
                        itemPosition.put(item, position);
                    } else {
                        pos.expand(position);
                    }
                }

                public Position get(int item) {
                    return itemPosition.get(item);
                }

                @Override
                public String toString() {
                    return "ItemPosition{" + "itemPosition=" + itemPosition + '}';
                }
            }

            ----------------------------------------------------------------------------------------------------------------

                private static class RuleWithTransactions {

                    private final BitSet transactions;
                    private final Itemset x, y;

                    private final double support, supportRatio, ORconf;
                    private final double lift;

                    public RuleWithTransactions(Itemset x, Itemset y, BitSet transactions, double ruleSup,
                                                double supportRatio, double confidence, double lift) {
                        this.x = x;
                        this.y = y;
                        this.transactions = transactions;
                        this.ORconf = confidence;
                        this.support = ruleSup;
                        this.supportRatio = supportRatio;
                        this.lift = lift;
                    }

                    public double getSupport() {
                        return support;
                    }

                    public double getSupportRatio() {
                        return supportRatio;
                    }

                    public double getORconf() {
                        return ORconf;
                    }

                    public double getLift() {
                        return lift;
                    }

                    public double frequency() {
                        return transactions.cardinality();
                    }

                    @Override
                    public String toString() {
                        return "{<" + x + " => " + y + "> freq: " + transactions + "}";
                    }
                }

                -------------------------------------------------------------------------------------------------------------
                    private static class Rule {
                        private final Itemset x, y;
                        private final double support, supportRatio, confidence, lift;

                        public Rule(RuleWithTransactions rule) {
                            this.x = rule.getX();
                            this.y = rule.getY();
                            this.support = rule.getSupport();
                            this.supportRatio = rule.getSupportRatio();
                            this.confidence = rule.getORconf();
                            this.lift = rule.getLift();
                        }

                        public Itemset getX() {
                            return x;
                        }

                        public Itemset getY() {
                            return y;
                        }

                        public double getSupport() {
                            return support;
                        }

                        public double getSupportRatio() {
                            return supportRatio;
                        }

                        public double getConfidence() {
                            return confidence;
                        }

                        public double getLift() {
                            return lift;
                        }
                    }

                    --------------------------------------------------------------------------------------------------------

                        private static class ItemsetWithTransactions {
                            private Itemset itemSet;
                            private final BitSet transactions;

                            public ItemsetWithTransactions(Itemset item, BitSet transactions) {
                                this.itemSet = item;
                                this.transactions = transactions;
                            }

                            public double frequency() {
                                return transactions.cardinality();
                            }

                            public BitSet getTransactions() {
                                return transactions;
                            }

                            public Itemset getItemSet() {
                                return itemSet;
                            }

                            @Override
                            public boolean equals(Object o) {
                                if (this == o)
                                    return true;
                                if (o == null || getClass() != o.getClass())
                                    return false;

                                ItemsetWithTransactions itemSet = (ItemsetWithTransactions) o;
                                return this.itemSet.equals(itemSet.itemSet);
                            }

                            @Override
                            public int hashCode() {
                                return itemSet.hashCode();
                            }

                            @Override
                            public String toString() {
                                return "#{" + itemSet + " freq:" + frequency() + "}";
                            }
                        }

                        -----------------------------------------------------------------------------------------------------

                            public static void main(String[] args) throws IOException {
                                Options options = new Options();
                                options.addOption("minSup", true, "minimum support");
                                options.addOption("minSupRatio", true, "minimum support ratio");
                                options.addOption("minConf", true, "minimum confidence");
                                options.addOption("delta", true, "min temporal distance");
                                options.addOption("input", true, "input file (use -time if time information is given)");
                                options.addOption("time", false, "true if file contains no temporal information (event label, time)");
                                options.addOption("output", true, "file for writing the results (default: write to standard out)");

                                CommandLineParser parser = new DefaultParser();
                                CommandLine cmd;
                                try {
                                    cmd = parser.parse(options, args);


                                    String file = cmd.getOptionValue("input");
                                    if (file == null) {
                                        throw new RuntimeException("no input");
                                    }
                                    TransactionInput transactionInput = readTransactions(file, !cmd.hasOption("time"));
                                    System.out.println(transactionInput.transactions);
                                    double minSup = Double.parseDouble(cmd.getOptionValue("minSup", "0.1"));
                                    double minSupRatio = Double.parseDouble(cmd.getOptionValue("minSupRatio", "0.0"));
                                    double minConf = Double.parseDouble(cmd.getOptionValue("minConf", "0.4"));;
                                    int orderConstraint = Integer.parseInt(cmd.getOptionValue("delta", "1"));

                                    long start = System.currentTimeMillis();
                                    List<Rule> rules =
                                            findFrequent(transactionInput, minSup, minSupRatio, orderConstraint, minConf);

                                    String output = cmd.getOptionValue("output", "<std>");
                                    PrintStream out;
                                    if ("<std>".equalsIgnoreCase(output)) {
                                        out = System.out;
                                    } else {
                                        out = new PrintStream(new FileOutputStream(output));
                                    }
                                    System.err.printf("Found %d rules in %d ms with %.4f MB memory %n", rules.size(),
                                            System.currentTimeMillis() - start,
                                            (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024.0
                                                    / 1024.0);
                                    out.printf("Rule, support, supportRatio, conf, lift%n");
                                    rules.stream().sorted(Comparator.comparing(Rule::getSupport).reversed()).forEach(rule -> {
                                        out.printf("\"%s => %s\",%f,%f,%f,%f%n", rule.getX(), rule.getY(), rule.getSupport(),
                                                rule.getSupportRatio(), rule.getConfidence(), rule.getLift());
                                    });

                                    out.flush();
                                } catch (Exception e) {
                                    e.printStackTrace();
                                    HelpFormatter formatter = new HelpFormatter();
                                    formatter.printHelp("KAPMiner", options);
                                    System.exit(0);
                                }
                            }

                         ---------------------------------------------------------------------------------------------------------